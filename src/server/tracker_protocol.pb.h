// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tracker_protocol.proto

#ifndef PROTOBUF_tracker_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_tracker_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace fastdcs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tracker_5fprotocol_2eproto();
void protobuf_AssignDesc_tracker_5fprotocol_2eproto();
void protobuf_ShutdownFile_tracker_5fprotocol_2eproto();

class KeyValuePair;
class KeyValuesPair;
class FdcsTask;
class TrackerStatus;
class TrackerProtocol;

enum OperateType {
  UNKNOWN_OPERATE = 0,
  NEW_OPERATE = 1,
  DELETE_OPERATE = 2,
  MODIFY_OPERATE = 3
};
bool OperateType_IsValid(int value);
const OperateType OperateType_MIN = UNKNOWN_OPERATE;
const OperateType OperateType_MAX = MODIFY_OPERATE;
const int OperateType_ARRAYSIZE = OperateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperateType_descriptor();
inline const ::std::string& OperateType_Name(OperateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperateType_descriptor(), value);
}
inline bool OperateType_Parse(
    const ::std::string& name, OperateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperateType>(
    OperateType_descriptor(), name, value);
}
enum PriorityType {
  IDLE_PRIORITY = 0,
  BELOW_PRIORITY = 1,
  NORMAL_PRIORITY = 2,
  ABOVE_NORMAL_PRIORITY = 3,
  REALTIME_PRIORITY = 4
};
bool PriorityType_IsValid(int value);
const PriorityType PriorityType_MIN = IDLE_PRIORITY;
const PriorityType PriorityType_MAX = REALTIME_PRIORITY;
const int PriorityType_ARRAYSIZE = PriorityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriorityType_descriptor();
inline const ::std::string& PriorityType_Name(PriorityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriorityType_descriptor(), value);
}
inline bool PriorityType_Parse(
    const ::std::string& name, PriorityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriorityType>(
    PriorityType_descriptor(), name, value);
}
enum TrackerType {
  UNKNOWN_TRACKER = 0,
  MASTER_TYPE = 1,
  WORKER_TYPE = 2,
  CLIENT_TYPE = 3
};
bool TrackerType_IsValid(int value);
const TrackerType TrackerType_MIN = UNKNOWN_TRACKER;
const TrackerType TrackerType_MAX = CLIENT_TYPE;
const int TrackerType_ARRAYSIZE = TrackerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrackerType_descriptor();
inline const ::std::string& TrackerType_Name(TrackerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrackerType_descriptor(), value);
}
inline bool TrackerType_Parse(
    const ::std::string& name, TrackerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrackerType>(
    TrackerType_descriptor(), name, value);
}
enum ProtocolType {
  UNKNOWN_PROTOCOL = 0,
  ELECTION = 1,
  COORDINATOR = 2,
  MASTER_ASK_TRACKER = 3,
  MASTER_REPORT_STATUS = 4,
  WORKER_ASK_TRACKER = 5,
  WORKER_REPORT_STATUS = 6,
  CREATE_JOB_ID = 7,
  COMMIT_JOB = 8,
  SYNC_TASK_DUPLICATE = 9,
  REQUEST_TASK_DUPLICATE = 10,
  WORKER_REQUEST_TASK = 11,
  TASK_COMPLETED = 12,
  ASK_TASK_STATUS = 13,
  MASTER_JOIN_GROUP = 14,
  MASTER_GROUP_CHANGED = 15
};
bool ProtocolType_IsValid(int value);
const ProtocolType ProtocolType_MIN = UNKNOWN_PROTOCOL;
const ProtocolType ProtocolType_MAX = MASTER_GROUP_CHANGED;
const int ProtocolType_ARRAYSIZE = ProtocolType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtocolType_descriptor();
inline const ::std::string& ProtocolType_Name(ProtocolType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtocolType_descriptor(), value);
}
inline bool ProtocolType_Parse(
    const ::std::string& name, ProtocolType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtocolType>(
    ProtocolType_descriptor(), name, value);
}
// ===================================================================

class KeyValuePair : public ::google::protobuf::Message {
 public:
  KeyValuePair();
  virtual ~KeyValuePair();
  
  KeyValuePair(const KeyValuePair& from);
  
  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValuePair& default_instance();
  
  void Swap(KeyValuePair* other);
  
  // implements Message ----------------------------------------------
  
  KeyValuePair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValuePair& from);
  void MergeFrom(const KeyValuePair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:fastdcs.KeyValuePair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static KeyValuePair* default_instance_;
};
// -------------------------------------------------------------------

class KeyValuesPair : public ::google::protobuf::Message {
 public:
  KeyValuesPair();
  virtual ~KeyValuesPair();
  
  KeyValuesPair(const KeyValuesPair& from);
  
  inline KeyValuesPair& operator=(const KeyValuesPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValuesPair& default_instance();
  
  void Swap(KeyValuesPair* other);
  
  // implements Message ----------------------------------------------
  
  KeyValuesPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValuesPair& from);
  void MergeFrom(const KeyValuesPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // repeated bytes value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value(int index) const;
  inline ::std::string* mutable_value(int index);
  inline void set_value(int index, const ::std::string& value);
  inline void set_value(int index, const char* value);
  inline void set_value(int index, const void* value, size_t size);
  inline ::std::string* add_value();
  inline void add_value(const ::std::string& value);
  inline void add_value(const char* value);
  inline void add_value(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();
  
  // @@protoc_insertion_point(class_scope:fastdcs.KeyValuesPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static KeyValuesPair* default_instance_;
};
// -------------------------------------------------------------------

class FdcsTask : public ::google::protobuf::Message {
 public:
  FdcsTask();
  virtual ~FdcsTask();
  
  FdcsTask(const FdcsTask& from);
  
  inline FdcsTask& operator=(const FdcsTask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FdcsTask& default_instance();
  
  void Swap(FdcsTask* other);
  
  // implements Message ----------------------------------------------
  
  FdcsTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FdcsTask& from);
  void MergeFrom(const FdcsTask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string task_id = 1 [default = ""];
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  
  // optional int64 lease_time = 2 [default = 0];
  inline bool has_lease_time() const;
  inline void clear_lease_time();
  static const int kLeaseTimeFieldNumber = 2;
  inline ::google::protobuf::int64 lease_time() const;
  inline void set_lease_time(::google::protobuf::int64 value);
  
  // repeated .fastdcs.KeyValuesPair key_values_pairs = 3;
  inline int key_values_pairs_size() const;
  inline void clear_key_values_pairs();
  static const int kKeyValuesPairsFieldNumber = 3;
  inline const ::fastdcs::KeyValuesPair& key_values_pairs(int index) const;
  inline ::fastdcs::KeyValuesPair* mutable_key_values_pairs(int index);
  inline ::fastdcs::KeyValuesPair* add_key_values_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair >&
      key_values_pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair >*
      mutable_key_values_pairs();
  
  // @@protoc_insertion_point(class_scope:fastdcs.FdcsTask)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_lease_time();
  inline void clear_has_lease_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* task_id_;
  ::google::protobuf::int64 lease_time_;
  ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair > key_values_pairs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static FdcsTask* default_instance_;
};
// -------------------------------------------------------------------

class TrackerStatus : public ::google::protobuf::Message {
 public:
  TrackerStatus();
  virtual ~TrackerStatus();
  
  TrackerStatus(const TrackerStatus& from);
  
  inline TrackerStatus& operator=(const TrackerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackerStatus& default_instance();
  
  void Swap(TrackerStatus* other);
  
  // implements Message ----------------------------------------------
  
  TrackerStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackerStatus& from);
  void MergeFrom(const TrackerStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string socket_addr = 1 [default = ""];
  inline bool has_socket_addr() const;
  inline void clear_socket_addr();
  static const int kSocketAddrFieldNumber = 1;
  inline const ::std::string& socket_addr() const;
  inline void set_socket_addr(const ::std::string& value);
  inline void set_socket_addr(const char* value);
  inline void set_socket_addr(const char* value, size_t size);
  inline ::std::string* mutable_socket_addr();
  inline ::std::string* release_socket_addr();
  
  // optional bool active = 2 [default = false];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 2;
  inline bool active() const;
  inline void set_active(bool value);
  
  // optional .fastdcs.TrackerType tracker_type = 3 [default = UNKNOWN_TRACKER];
  inline bool has_tracker_type() const;
  inline void clear_tracker_type();
  static const int kTrackerTypeFieldNumber = 3;
  inline fastdcs::TrackerType tracker_type() const;
  inline void set_tracker_type(fastdcs::TrackerType value);
  
  // optional string start_time = 4 [default = ""];
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 4;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const char* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  
  // optional string run_time = 5 [default = ""];
  inline bool has_run_time() const;
  inline void clear_run_time();
  static const int kRunTimeFieldNumber = 5;
  inline const ::std::string& run_time() const;
  inline void set_run_time(const ::std::string& value);
  inline void set_run_time(const char* value);
  inline void set_run_time(const char* value, size_t size);
  inline ::std::string* mutable_run_time();
  inline ::std::string* release_run_time();
  
  // optional int32 process_num = 6 [default = 0];
  inline bool has_process_num() const;
  inline void clear_process_num();
  static const int kProcessNumFieldNumber = 6;
  inline ::google::protobuf::int32 process_num() const;
  inline void set_process_num(::google::protobuf::int32 value);
  
  // optional int32 free_disk = 7 [default = 0];
  inline bool has_free_disk() const;
  inline void clear_free_disk();
  static const int kFreeDiskFieldNumber = 7;
  inline ::google::protobuf::int32 free_disk() const;
  inline void set_free_disk(::google::protobuf::int32 value);
  
  // optional int32 total_disk = 8 [default = 0];
  inline bool has_total_disk() const;
  inline void clear_total_disk();
  static const int kTotalDiskFieldNumber = 8;
  inline ::google::protobuf::int32 total_disk() const;
  inline void set_total_disk(::google::protobuf::int32 value);
  
  // optional int32 free_memory = 9 [default = 0];
  inline bool has_free_memory() const;
  inline void clear_free_memory();
  static const int kFreeMemoryFieldNumber = 9;
  inline ::google::protobuf::int32 free_memory() const;
  inline void set_free_memory(::google::protobuf::int32 value);
  
  // optional int32 total_memory = 10 [default = 0];
  inline bool has_total_memory() const;
  inline void clear_total_memory();
  static const int kTotalMemoryFieldNumber = 10;
  inline ::google::protobuf::int32 total_memory() const;
  inline void set_total_memory(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:fastdcs.TrackerStatus)
 private:
  inline void set_has_socket_addr();
  inline void clear_has_socket_addr();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_tracker_type();
  inline void clear_has_tracker_type();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_run_time();
  inline void clear_has_run_time();
  inline void set_has_process_num();
  inline void clear_has_process_num();
  inline void set_has_free_disk();
  inline void clear_has_free_disk();
  inline void set_has_total_disk();
  inline void clear_has_total_disk();
  inline void set_has_free_memory();
  inline void clear_has_free_memory();
  inline void set_has_total_memory();
  inline void clear_has_total_memory();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* socket_addr_;
  bool active_;
  int tracker_type_;
  ::std::string* start_time_;
  ::std::string* run_time_;
  ::google::protobuf::int32 process_num_;
  ::google::protobuf::int32 free_disk_;
  ::google::protobuf::int32 total_disk_;
  ::google::protobuf::int32 free_memory_;
  ::google::protobuf::int32 total_memory_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static TrackerStatus* default_instance_;
};
// -------------------------------------------------------------------

class TrackerProtocol : public ::google::protobuf::Message {
 public:
  TrackerProtocol();
  virtual ~TrackerProtocol();
  
  TrackerProtocol(const TrackerProtocol& from);
  
  inline TrackerProtocol& operator=(const TrackerProtocol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackerProtocol& default_instance();
  
  void Swap(TrackerProtocol* other);
  
  // implements Message ----------------------------------------------
  
  TrackerProtocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackerProtocol& from);
  void MergeFrom(const TrackerProtocol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);
  
  // optional int64 time = 2 [default = 0];
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional .fastdcs.ProtocolType protocol_type = 3 [default = UNKNOWN_PROTOCOL];
  inline bool has_protocol_type() const;
  inline void clear_protocol_type();
  static const int kProtocolTypeFieldNumber = 3;
  inline fastdcs::ProtocolType protocol_type() const;
  inline void set_protocol_type(fastdcs::ProtocolType value);
  
  // optional .fastdcs.TrackerType tracker_type = 4 [default = UNKNOWN_TRACKER];
  inline bool has_tracker_type() const;
  inline void clear_tracker_type();
  static const int kTrackerTypeFieldNumber = 4;
  inline fastdcs::TrackerType tracker_type() const;
  inline void set_tracker_type(fastdcs::TrackerType value);
  
  // optional string request_sock_addr = 5 [default = ""];
  inline bool has_request_sock_addr() const;
  inline void clear_request_sock_addr();
  static const int kRequestSockAddrFieldNumber = 5;
  inline const ::std::string& request_sock_addr() const;
  inline void set_request_sock_addr(const ::std::string& value);
  inline void set_request_sock_addr(const char* value);
  inline void set_request_sock_addr(const char* value, size_t size);
  inline ::std::string* mutable_request_sock_addr();
  inline ::std::string* release_request_sock_addr();
  
  // optional string request_args = 6 [default = ""];
  inline bool has_request_args() const;
  inline void clear_request_args();
  static const int kRequestArgsFieldNumber = 6;
  inline const ::std::string& request_args() const;
  inline void set_request_args(const ::std::string& value);
  inline void set_request_args(const char* value);
  inline void set_request_args(const char* value, size_t size);
  inline ::std::string* mutable_request_args();
  inline ::std::string* release_request_args();
  
  // optional string response_sock_addr = 7 [default = ""];
  inline bool has_response_sock_addr() const;
  inline void clear_response_sock_addr();
  static const int kResponseSockAddrFieldNumber = 7;
  inline const ::std::string& response_sock_addr() const;
  inline void set_response_sock_addr(const ::std::string& value);
  inline void set_response_sock_addr(const char* value);
  inline void set_response_sock_addr(const char* value, size_t size);
  inline ::std::string* mutable_response_sock_addr();
  inline ::std::string* release_response_sock_addr();
  
  // optional int32 forwarding_sock_fd = 8 [default = -1];
  inline bool has_forwarding_sock_fd() const;
  inline void clear_forwarding_sock_fd();
  static const int kForwardingSockFdFieldNumber = 8;
  inline ::google::protobuf::int32 forwarding_sock_fd() const;
  inline void set_forwarding_sock_fd(::google::protobuf::int32 value);
  
  // optional string response_result = 9 [default = ""];
  inline bool has_response_result() const;
  inline void clear_response_result();
  static const int kResponseResultFieldNumber = 9;
  inline const ::std::string& response_result() const;
  inline void set_response_result(const ::std::string& value);
  inline void set_response_result(const char* value);
  inline void set_response_result(const char* value, size_t size);
  inline ::std::string* mutable_response_result();
  inline ::std::string* release_response_result();
  
  // repeated .fastdcs.TrackerStatus tracker_status = 10;
  inline int tracker_status_size() const;
  inline void clear_tracker_status();
  static const int kTrackerStatusFieldNumber = 10;
  inline const ::fastdcs::TrackerStatus& tracker_status(int index) const;
  inline ::fastdcs::TrackerStatus* mutable_tracker_status(int index);
  inline ::fastdcs::TrackerStatus* add_tracker_status();
  inline const ::google::protobuf::RepeatedPtrField< ::fastdcs::TrackerStatus >&
      tracker_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::fastdcs::TrackerStatus >*
      mutable_tracker_status();
  
  // repeated .fastdcs.KeyValuesPair key_values_pairs = 11;
  inline int key_values_pairs_size() const;
  inline void clear_key_values_pairs();
  static const int kKeyValuesPairsFieldNumber = 11;
  inline const ::fastdcs::KeyValuesPair& key_values_pairs(int index) const;
  inline ::fastdcs::KeyValuesPair* mutable_key_values_pairs(int index);
  inline ::fastdcs::KeyValuesPair* add_key_values_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair >&
      key_values_pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair >*
      mutable_key_values_pairs();
  
  // @@protoc_insertion_point(class_scope:fastdcs.TrackerProtocol)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_protocol_type();
  inline void clear_has_protocol_type();
  inline void set_has_tracker_type();
  inline void clear_has_tracker_type();
  inline void set_has_request_sock_addr();
  inline void clear_has_request_sock_addr();
  inline void set_has_request_args();
  inline void clear_has_request_args();
  inline void set_has_response_sock_addr();
  inline void clear_has_response_sock_addr();
  inline void set_has_forwarding_sock_fd();
  inline void clear_has_forwarding_sock_fd();
  inline void set_has_response_result();
  inline void clear_has_response_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 time_;
  int protocol_type_;
  int tracker_type_;
  ::std::string* request_sock_addr_;
  ::std::string* request_args_;
  ::std::string* response_sock_addr_;
  ::std::string* response_result_;
  ::google::protobuf::RepeatedPtrField< ::fastdcs::TrackerStatus > tracker_status_;
  ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair > key_values_pairs_;
  ::google::protobuf::int32 forwarding_sock_fd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_tracker_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fprotocol_2eproto();
  
  void InitAsDefaultInstance();
  static TrackerProtocol* default_instance_;
};
// ===================================================================


// ===================================================================

// KeyValuePair

// optional bytes key = 1;
inline bool KeyValuePair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValuePair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValuePair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValuePair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KeyValuePair::key() const {
  return *key_;
}
inline void KeyValuePair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValuePair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValuePair::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValuePair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* KeyValuePair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes value = 2;
inline bool KeyValuePair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValuePair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValuePair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValuePair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& KeyValuePair::value() const {
  return *value_;
}
inline void KeyValuePair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void KeyValuePair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void KeyValuePair::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValuePair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* KeyValuePair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// KeyValuesPair

// optional bytes key = 1;
inline bool KeyValuesPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValuesPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValuesPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValuesPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KeyValuesPair::key() const {
  return *key_;
}
inline void KeyValuesPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValuesPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValuesPair::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValuesPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* KeyValuesPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bytes value = 2;
inline int KeyValuesPair::value_size() const {
  return value_.size();
}
inline void KeyValuesPair::clear_value() {
  value_.Clear();
}
inline const ::std::string& KeyValuesPair::value(int index) const {
  return value_.Get(index);
}
inline ::std::string* KeyValuesPair::mutable_value(int index) {
  return value_.Mutable(index);
}
inline void KeyValuesPair::set_value(int index, const ::std::string& value) {
  value_.Mutable(index)->assign(value);
}
inline void KeyValuesPair::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
}
inline void KeyValuesPair::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValuesPair::add_value() {
  return value_.Add();
}
inline void KeyValuesPair::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
}
inline void KeyValuesPair::add_value(const char* value) {
  value_.Add()->assign(value);
}
inline void KeyValuesPair::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KeyValuesPair::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KeyValuesPair::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// FdcsTask

// required string task_id = 1 [default = ""];
inline bool FdcsTask::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FdcsTask::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FdcsTask::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FdcsTask::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::kEmptyString) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& FdcsTask::task_id() const {
  return *task_id_;
}
inline void FdcsTask::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void FdcsTask::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
}
inline void FdcsTask::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FdcsTask::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    task_id_ = new ::std::string;
  }
  return task_id_;
}
inline ::std::string* FdcsTask::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 lease_time = 2 [default = 0];
inline bool FdcsTask::has_lease_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FdcsTask::set_has_lease_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FdcsTask::clear_has_lease_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FdcsTask::clear_lease_time() {
  lease_time_ = GOOGLE_LONGLONG(0);
  clear_has_lease_time();
}
inline ::google::protobuf::int64 FdcsTask::lease_time() const {
  return lease_time_;
}
inline void FdcsTask::set_lease_time(::google::protobuf::int64 value) {
  set_has_lease_time();
  lease_time_ = value;
}

// repeated .fastdcs.KeyValuesPair key_values_pairs = 3;
inline int FdcsTask::key_values_pairs_size() const {
  return key_values_pairs_.size();
}
inline void FdcsTask::clear_key_values_pairs() {
  key_values_pairs_.Clear();
}
inline const ::fastdcs::KeyValuesPair& FdcsTask::key_values_pairs(int index) const {
  return key_values_pairs_.Get(index);
}
inline ::fastdcs::KeyValuesPair* FdcsTask::mutable_key_values_pairs(int index) {
  return key_values_pairs_.Mutable(index);
}
inline ::fastdcs::KeyValuesPair* FdcsTask::add_key_values_pairs() {
  return key_values_pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair >&
FdcsTask::key_values_pairs() const {
  return key_values_pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair >*
FdcsTask::mutable_key_values_pairs() {
  return &key_values_pairs_;
}

// -------------------------------------------------------------------

// TrackerStatus

// optional string socket_addr = 1 [default = ""];
inline bool TrackerStatus::has_socket_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackerStatus::set_has_socket_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackerStatus::clear_has_socket_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackerStatus::clear_socket_addr() {
  if (socket_addr_ != &::google::protobuf::internal::kEmptyString) {
    socket_addr_->clear();
  }
  clear_has_socket_addr();
}
inline const ::std::string& TrackerStatus::socket_addr() const {
  return *socket_addr_;
}
inline void TrackerStatus::set_socket_addr(const ::std::string& value) {
  set_has_socket_addr();
  if (socket_addr_ == &::google::protobuf::internal::kEmptyString) {
    socket_addr_ = new ::std::string;
  }
  socket_addr_->assign(value);
}
inline void TrackerStatus::set_socket_addr(const char* value) {
  set_has_socket_addr();
  if (socket_addr_ == &::google::protobuf::internal::kEmptyString) {
    socket_addr_ = new ::std::string;
  }
  socket_addr_->assign(value);
}
inline void TrackerStatus::set_socket_addr(const char* value, size_t size) {
  set_has_socket_addr();
  if (socket_addr_ == &::google::protobuf::internal::kEmptyString) {
    socket_addr_ = new ::std::string;
  }
  socket_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackerStatus::mutable_socket_addr() {
  set_has_socket_addr();
  if (socket_addr_ == &::google::protobuf::internal::kEmptyString) {
    socket_addr_ = new ::std::string;
  }
  return socket_addr_;
}
inline ::std::string* TrackerStatus::release_socket_addr() {
  clear_has_socket_addr();
  if (socket_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = socket_addr_;
    socket_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool active = 2 [default = false];
inline bool TrackerStatus::has_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackerStatus::set_has_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackerStatus::clear_has_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackerStatus::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool TrackerStatus::active() const {
  return active_;
}
inline void TrackerStatus::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// optional .fastdcs.TrackerType tracker_type = 3 [default = UNKNOWN_TRACKER];
inline bool TrackerStatus::has_tracker_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackerStatus::set_has_tracker_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackerStatus::clear_has_tracker_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackerStatus::clear_tracker_type() {
  tracker_type_ = 0;
  clear_has_tracker_type();
}
inline fastdcs::TrackerType TrackerStatus::tracker_type() const {
  return static_cast< fastdcs::TrackerType >(tracker_type_);
}
inline void TrackerStatus::set_tracker_type(fastdcs::TrackerType value) {
  GOOGLE_DCHECK(fastdcs::TrackerType_IsValid(value));
  set_has_tracker_type();
  tracker_type_ = value;
}

// optional string start_time = 4 [default = ""];
inline bool TrackerStatus::has_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackerStatus::set_has_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackerStatus::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackerStatus::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::kEmptyString) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& TrackerStatus::start_time() const {
  return *start_time_;
}
inline void TrackerStatus::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void TrackerStatus::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void TrackerStatus::set_start_time(const char* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackerStatus::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  return start_time_;
}
inline ::std::string* TrackerStatus::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string run_time = 5 [default = ""];
inline bool TrackerStatus::has_run_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackerStatus::set_has_run_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackerStatus::clear_has_run_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackerStatus::clear_run_time() {
  if (run_time_ != &::google::protobuf::internal::kEmptyString) {
    run_time_->clear();
  }
  clear_has_run_time();
}
inline const ::std::string& TrackerStatus::run_time() const {
  return *run_time_;
}
inline void TrackerStatus::set_run_time(const ::std::string& value) {
  set_has_run_time();
  if (run_time_ == &::google::protobuf::internal::kEmptyString) {
    run_time_ = new ::std::string;
  }
  run_time_->assign(value);
}
inline void TrackerStatus::set_run_time(const char* value) {
  set_has_run_time();
  if (run_time_ == &::google::protobuf::internal::kEmptyString) {
    run_time_ = new ::std::string;
  }
  run_time_->assign(value);
}
inline void TrackerStatus::set_run_time(const char* value, size_t size) {
  set_has_run_time();
  if (run_time_ == &::google::protobuf::internal::kEmptyString) {
    run_time_ = new ::std::string;
  }
  run_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackerStatus::mutable_run_time() {
  set_has_run_time();
  if (run_time_ == &::google::protobuf::internal::kEmptyString) {
    run_time_ = new ::std::string;
  }
  return run_time_;
}
inline ::std::string* TrackerStatus::release_run_time() {
  clear_has_run_time();
  if (run_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = run_time_;
    run_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 process_num = 6 [default = 0];
inline bool TrackerStatus::has_process_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackerStatus::set_has_process_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackerStatus::clear_has_process_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackerStatus::clear_process_num() {
  process_num_ = 0;
  clear_has_process_num();
}
inline ::google::protobuf::int32 TrackerStatus::process_num() const {
  return process_num_;
}
inline void TrackerStatus::set_process_num(::google::protobuf::int32 value) {
  set_has_process_num();
  process_num_ = value;
}

// optional int32 free_disk = 7 [default = 0];
inline bool TrackerStatus::has_free_disk() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackerStatus::set_has_free_disk() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackerStatus::clear_has_free_disk() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackerStatus::clear_free_disk() {
  free_disk_ = 0;
  clear_has_free_disk();
}
inline ::google::protobuf::int32 TrackerStatus::free_disk() const {
  return free_disk_;
}
inline void TrackerStatus::set_free_disk(::google::protobuf::int32 value) {
  set_has_free_disk();
  free_disk_ = value;
}

// optional int32 total_disk = 8 [default = 0];
inline bool TrackerStatus::has_total_disk() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrackerStatus::set_has_total_disk() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrackerStatus::clear_has_total_disk() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrackerStatus::clear_total_disk() {
  total_disk_ = 0;
  clear_has_total_disk();
}
inline ::google::protobuf::int32 TrackerStatus::total_disk() const {
  return total_disk_;
}
inline void TrackerStatus::set_total_disk(::google::protobuf::int32 value) {
  set_has_total_disk();
  total_disk_ = value;
}

// optional int32 free_memory = 9 [default = 0];
inline bool TrackerStatus::has_free_memory() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrackerStatus::set_has_free_memory() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrackerStatus::clear_has_free_memory() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrackerStatus::clear_free_memory() {
  free_memory_ = 0;
  clear_has_free_memory();
}
inline ::google::protobuf::int32 TrackerStatus::free_memory() const {
  return free_memory_;
}
inline void TrackerStatus::set_free_memory(::google::protobuf::int32 value) {
  set_has_free_memory();
  free_memory_ = value;
}

// optional int32 total_memory = 10 [default = 0];
inline bool TrackerStatus::has_total_memory() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrackerStatus::set_has_total_memory() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrackerStatus::clear_has_total_memory() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrackerStatus::clear_total_memory() {
  total_memory_ = 0;
  clear_has_total_memory();
}
inline ::google::protobuf::int32 TrackerStatus::total_memory() const {
  return total_memory_;
}
inline void TrackerStatus::set_total_memory(::google::protobuf::int32 value) {
  set_has_total_memory();
  total_memory_ = value;
}

// -------------------------------------------------------------------

// TrackerProtocol

// required int64 id = 1 [default = 0];
inline bool TrackerProtocol::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackerProtocol::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackerProtocol::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackerProtocol::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 TrackerProtocol::id() const {
  return id_;
}
inline void TrackerProtocol::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int64 time = 2 [default = 0];
inline bool TrackerProtocol::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackerProtocol::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackerProtocol::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackerProtocol::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 TrackerProtocol::time() const {
  return time_;
}
inline void TrackerProtocol::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional .fastdcs.ProtocolType protocol_type = 3 [default = UNKNOWN_PROTOCOL];
inline bool TrackerProtocol::has_protocol_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackerProtocol::set_has_protocol_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackerProtocol::clear_has_protocol_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackerProtocol::clear_protocol_type() {
  protocol_type_ = 0;
  clear_has_protocol_type();
}
inline fastdcs::ProtocolType TrackerProtocol::protocol_type() const {
  return static_cast< fastdcs::ProtocolType >(protocol_type_);
}
inline void TrackerProtocol::set_protocol_type(fastdcs::ProtocolType value) {
  GOOGLE_DCHECK(fastdcs::ProtocolType_IsValid(value));
  set_has_protocol_type();
  protocol_type_ = value;
}

// optional .fastdcs.TrackerType tracker_type = 4 [default = UNKNOWN_TRACKER];
inline bool TrackerProtocol::has_tracker_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackerProtocol::set_has_tracker_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackerProtocol::clear_has_tracker_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackerProtocol::clear_tracker_type() {
  tracker_type_ = 0;
  clear_has_tracker_type();
}
inline fastdcs::TrackerType TrackerProtocol::tracker_type() const {
  return static_cast< fastdcs::TrackerType >(tracker_type_);
}
inline void TrackerProtocol::set_tracker_type(fastdcs::TrackerType value) {
  GOOGLE_DCHECK(fastdcs::TrackerType_IsValid(value));
  set_has_tracker_type();
  tracker_type_ = value;
}

// optional string request_sock_addr = 5 [default = ""];
inline bool TrackerProtocol::has_request_sock_addr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackerProtocol::set_has_request_sock_addr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackerProtocol::clear_has_request_sock_addr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackerProtocol::clear_request_sock_addr() {
  if (request_sock_addr_ != &::google::protobuf::internal::kEmptyString) {
    request_sock_addr_->clear();
  }
  clear_has_request_sock_addr();
}
inline const ::std::string& TrackerProtocol::request_sock_addr() const {
  return *request_sock_addr_;
}
inline void TrackerProtocol::set_request_sock_addr(const ::std::string& value) {
  set_has_request_sock_addr();
  if (request_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    request_sock_addr_ = new ::std::string;
  }
  request_sock_addr_->assign(value);
}
inline void TrackerProtocol::set_request_sock_addr(const char* value) {
  set_has_request_sock_addr();
  if (request_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    request_sock_addr_ = new ::std::string;
  }
  request_sock_addr_->assign(value);
}
inline void TrackerProtocol::set_request_sock_addr(const char* value, size_t size) {
  set_has_request_sock_addr();
  if (request_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    request_sock_addr_ = new ::std::string;
  }
  request_sock_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackerProtocol::mutable_request_sock_addr() {
  set_has_request_sock_addr();
  if (request_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    request_sock_addr_ = new ::std::string;
  }
  return request_sock_addr_;
}
inline ::std::string* TrackerProtocol::release_request_sock_addr() {
  clear_has_request_sock_addr();
  if (request_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_sock_addr_;
    request_sock_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string request_args = 6 [default = ""];
inline bool TrackerProtocol::has_request_args() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackerProtocol::set_has_request_args() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackerProtocol::clear_has_request_args() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackerProtocol::clear_request_args() {
  if (request_args_ != &::google::protobuf::internal::kEmptyString) {
    request_args_->clear();
  }
  clear_has_request_args();
}
inline const ::std::string& TrackerProtocol::request_args() const {
  return *request_args_;
}
inline void TrackerProtocol::set_request_args(const ::std::string& value) {
  set_has_request_args();
  if (request_args_ == &::google::protobuf::internal::kEmptyString) {
    request_args_ = new ::std::string;
  }
  request_args_->assign(value);
}
inline void TrackerProtocol::set_request_args(const char* value) {
  set_has_request_args();
  if (request_args_ == &::google::protobuf::internal::kEmptyString) {
    request_args_ = new ::std::string;
  }
  request_args_->assign(value);
}
inline void TrackerProtocol::set_request_args(const char* value, size_t size) {
  set_has_request_args();
  if (request_args_ == &::google::protobuf::internal::kEmptyString) {
    request_args_ = new ::std::string;
  }
  request_args_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackerProtocol::mutable_request_args() {
  set_has_request_args();
  if (request_args_ == &::google::protobuf::internal::kEmptyString) {
    request_args_ = new ::std::string;
  }
  return request_args_;
}
inline ::std::string* TrackerProtocol::release_request_args() {
  clear_has_request_args();
  if (request_args_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_args_;
    request_args_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string response_sock_addr = 7 [default = ""];
inline bool TrackerProtocol::has_response_sock_addr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackerProtocol::set_has_response_sock_addr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackerProtocol::clear_has_response_sock_addr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackerProtocol::clear_response_sock_addr() {
  if (response_sock_addr_ != &::google::protobuf::internal::kEmptyString) {
    response_sock_addr_->clear();
  }
  clear_has_response_sock_addr();
}
inline const ::std::string& TrackerProtocol::response_sock_addr() const {
  return *response_sock_addr_;
}
inline void TrackerProtocol::set_response_sock_addr(const ::std::string& value) {
  set_has_response_sock_addr();
  if (response_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    response_sock_addr_ = new ::std::string;
  }
  response_sock_addr_->assign(value);
}
inline void TrackerProtocol::set_response_sock_addr(const char* value) {
  set_has_response_sock_addr();
  if (response_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    response_sock_addr_ = new ::std::string;
  }
  response_sock_addr_->assign(value);
}
inline void TrackerProtocol::set_response_sock_addr(const char* value, size_t size) {
  set_has_response_sock_addr();
  if (response_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    response_sock_addr_ = new ::std::string;
  }
  response_sock_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackerProtocol::mutable_response_sock_addr() {
  set_has_response_sock_addr();
  if (response_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    response_sock_addr_ = new ::std::string;
  }
  return response_sock_addr_;
}
inline ::std::string* TrackerProtocol::release_response_sock_addr() {
  clear_has_response_sock_addr();
  if (response_sock_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_sock_addr_;
    response_sock_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 forwarding_sock_fd = 8 [default = -1];
inline bool TrackerProtocol::has_forwarding_sock_fd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrackerProtocol::set_has_forwarding_sock_fd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrackerProtocol::clear_has_forwarding_sock_fd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrackerProtocol::clear_forwarding_sock_fd() {
  forwarding_sock_fd_ = -1;
  clear_has_forwarding_sock_fd();
}
inline ::google::protobuf::int32 TrackerProtocol::forwarding_sock_fd() const {
  return forwarding_sock_fd_;
}
inline void TrackerProtocol::set_forwarding_sock_fd(::google::protobuf::int32 value) {
  set_has_forwarding_sock_fd();
  forwarding_sock_fd_ = value;
}

// optional string response_result = 9 [default = ""];
inline bool TrackerProtocol::has_response_result() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrackerProtocol::set_has_response_result() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrackerProtocol::clear_has_response_result() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrackerProtocol::clear_response_result() {
  if (response_result_ != &::google::protobuf::internal::kEmptyString) {
    response_result_->clear();
  }
  clear_has_response_result();
}
inline const ::std::string& TrackerProtocol::response_result() const {
  return *response_result_;
}
inline void TrackerProtocol::set_response_result(const ::std::string& value) {
  set_has_response_result();
  if (response_result_ == &::google::protobuf::internal::kEmptyString) {
    response_result_ = new ::std::string;
  }
  response_result_->assign(value);
}
inline void TrackerProtocol::set_response_result(const char* value) {
  set_has_response_result();
  if (response_result_ == &::google::protobuf::internal::kEmptyString) {
    response_result_ = new ::std::string;
  }
  response_result_->assign(value);
}
inline void TrackerProtocol::set_response_result(const char* value, size_t size) {
  set_has_response_result();
  if (response_result_ == &::google::protobuf::internal::kEmptyString) {
    response_result_ = new ::std::string;
  }
  response_result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackerProtocol::mutable_response_result() {
  set_has_response_result();
  if (response_result_ == &::google::protobuf::internal::kEmptyString) {
    response_result_ = new ::std::string;
  }
  return response_result_;
}
inline ::std::string* TrackerProtocol::release_response_result() {
  clear_has_response_result();
  if (response_result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_result_;
    response_result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .fastdcs.TrackerStatus tracker_status = 10;
inline int TrackerProtocol::tracker_status_size() const {
  return tracker_status_.size();
}
inline void TrackerProtocol::clear_tracker_status() {
  tracker_status_.Clear();
}
inline const ::fastdcs::TrackerStatus& TrackerProtocol::tracker_status(int index) const {
  return tracker_status_.Get(index);
}
inline ::fastdcs::TrackerStatus* TrackerProtocol::mutable_tracker_status(int index) {
  return tracker_status_.Mutable(index);
}
inline ::fastdcs::TrackerStatus* TrackerProtocol::add_tracker_status() {
  return tracker_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fastdcs::TrackerStatus >&
TrackerProtocol::tracker_status() const {
  return tracker_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::fastdcs::TrackerStatus >*
TrackerProtocol::mutable_tracker_status() {
  return &tracker_status_;
}

// repeated .fastdcs.KeyValuesPair key_values_pairs = 11;
inline int TrackerProtocol::key_values_pairs_size() const {
  return key_values_pairs_.size();
}
inline void TrackerProtocol::clear_key_values_pairs() {
  key_values_pairs_.Clear();
}
inline const ::fastdcs::KeyValuesPair& TrackerProtocol::key_values_pairs(int index) const {
  return key_values_pairs_.Get(index);
}
inline ::fastdcs::KeyValuesPair* TrackerProtocol::mutable_key_values_pairs(int index) {
  return key_values_pairs_.Mutable(index);
}
inline ::fastdcs::KeyValuesPair* TrackerProtocol::add_key_values_pairs() {
  return key_values_pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair >&
TrackerProtocol::key_values_pairs() const {
  return key_values_pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::fastdcs::KeyValuesPair >*
TrackerProtocol::mutable_key_values_pairs() {
  return &key_values_pairs_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fastdcs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< fastdcs::OperateType>() {
  return fastdcs::OperateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< fastdcs::PriorityType>() {
  return fastdcs::PriorityType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< fastdcs::TrackerType>() {
  return fastdcs::TrackerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< fastdcs::ProtocolType>() {
  return fastdcs::ProtocolType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tracker_5fprotocol_2eproto__INCLUDED
